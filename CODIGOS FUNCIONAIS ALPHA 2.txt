BOT:
require('dotenv').config();
const fs = require('fs');
const { default: makeWASocket, useMultiFileAuthState } = require('@whiskeysockets/baileys');
const axios = require('axios');
const redis = require('redis');
const SESSION_DIR = './sessions';
const API_URL = process.env.API_URL || "http://localhost:4000";
const ALLOW_GROUPS = process.env.ALLOW_GROUPS === 'true';

// üîπ Cria√ß√£o da pasta de sess√£o caso n√£o exista
if (!fs.existsSync(SESSION_DIR)) fs.mkdirSync(SESSION_DIR);

// üîπ Conex√£o com Redis para armazenar o estado dos usu√°rios
const client = redis.createClient();
client.connect().catch(err => console.error("‚ùå Erro ao conectar ao Redis:", err));

/**
 * üõ† Salva o estado do usu√°rio no Redis
 */
async function saveUserState(sender, state) {
    await client.set(`user:${sender}`, JSON.stringify(state), { EX: 600 }); // Expira em 10 minutos
}

/**
 * üõ† Obt√©m o estado do usu√°rio armazenado no Redis
 */
async function getUserState(sender) {
    const data = await client.get(`user:${sender}`);
    return data ? JSON.parse(data) : { status: "menu_inicial" };
}

/**
 * üõ† Remove o estado do usu√°rio, voltando ao estado inicial
 */
async function deleteUserState(sender) {
    await client.del(`user:${sender}`);
}

/**
 * üì® Envia a mensagem inicial do bot com as op√ß√µes do menu principal
 */
async function sendInitialMessage(sender, conn) {
    console.log(`üì© [BOT] Enviando mensagem inicial para ${sender}...`);
    await deleteUserState(sender);
    const greeting = getGreeting();
    const message = `${greeting} Eu sou o *Assistente Inteligente ALETO*.

üìú *Posso ajudar a encontrar leis e regulamentos para an√°lise.*

1Ô∏è‚É£ üìë Enviar um PDF  
2Ô∏è‚É£ üîç Pesquisar uma lei  
3Ô∏è‚É£ ‚ùå Sair  

üí° *Dica:* Sempre inicie sua pesquisa com a palavra *Lei*  
Exemplo: *Lei sobre transporte gratuito.*`;

    await conn.sendMessage(sender, { text: message });
}

/**
 * üîç Processa a pesquisa de leis na API e retorna os resultados
 */
async function processSearch(query, sender, conn, page = 1) {
    try {
        console.log(`üöÄ [API] Enviando pesquisa para a API: ${query}`);
        const response = await axios.get(`${API_URL}/buscar`, { params: { q: query, page } });

        console.log("‚úÖ [API] Resposta recebida com sucesso!");
        const data = response.data;

        if (!data.results || data.results.length === 0) {
            await conn.sendMessage(sender, { text: "‚ö†Ô∏è Nenhuma lei encontrada para essa pesquisa." });
            return;
        }
/**
* üîπ Formata a resposta da pesquisa textual (sem similaridade).
*/
        let message = "üìú *Leis relacionadas encontradas:*\n\n";
        data.results.forEach((law, index) => {
            message += `üìå *${index + 1}. ${law.title}*\n`; // üîπ Exibe o t√≠tulo da lei encontrada
            message += `üìÑ *Resumo:* ${law.snippet || "Sem resumo dispon√≠vel."}\n`; // üîπ Mostra o resumo da lei
            message += `üîó [üîé Acesse Aqui](${law.link})\n\n`; // üîπ Adiciona o link para acessar a lei completa
        });

        console.log("üì§ [BOT] Enviando resultado da pesquisa...");
        await conn.sendMessage(sender, { text: message });

        // üîπ Adicionando **menu p√≥s-pesquisa**
        await conn.sendMessage(sender, {
            text: "üîò *Escolha uma op√ß√£o abaixo:*\n\n" +
                "1Ô∏è‚É£ üìë Buscar mais leis similares...\n" +
                "2Ô∏è‚É£ üîç Fazer uma nova pesquisa\n" +
                "3Ô∏è‚É£ ‚ùå Sair"
        });

        // üîπ Mudando o estado do usu√°rio para menu_pesquisa
        await saveUserState(sender, { status: "menu_pesquisa", last_query: query, page });

    } catch (error) {
        console.error("‚ùå [API] Erro ao processar pesquisa:", error.message);
        await conn.sendMessage(sender, { text: "‚ùå Erro ao buscar leis. Tente novamente mais tarde." });
    }
}

/**
 * üöÄ Inicia o bot e gerencia eventos de mensagens
 */
async function startBot() {
    const { state, saveCreds } = await useMultiFileAuthState(SESSION_DIR);
    const conn = makeWASocket({
        auth: state,
        printQRInTerminal: true,
        browser: ["Ubuntu", "Chrome", "22.04.4"],
        syncFullHistory: true,
    });

    conn.ev.on('creds.update', saveCreds);

    conn.ev.on('messages.upsert', async (message) => {
        console.log("üì• [BOT] Nova mensagem recebida!");
        const msg = message.messages[0];
        if (!msg || msg.key.fromMe || !msg.message) return;

        const sender = msg.key.remoteJid;
        if (sender.endsWith("@g.us") && !ALLOW_GROUPS) {
            console.log("üö´ [BOT] Mensagem de grupo ignorada.");
            return;
        }

        let text = msg.message.conversation || msg.message.extendedTextMessage?.text || "";
        const normalizedText = text.toLowerCase().trim();
        let userStatus = await getUserState(sender);

        console.log(`üìå [BOT] Estado do usu√°rio (${sender}): ${JSON.stringify(userStatus)}`);

        if (userStatus.status === "waiting_law" && text) {
            console.log("üîç [BOT] Processando pesquisa de lei...");
            await processSearch(text, sender, conn);
            return;
        }

        if (userStatus.status === "menu_pesquisa") {
            if (/^1$|buscar.*mais/i.test(normalizedText)) {
                console.log("üîç [BOT] Usu√°rio quer buscar mais leis similares...");
                await conn.sendMessage(sender, { text: "üîé Buscando mais leis similares..." });
            
                // Obt√©m a pr√≥xima p√°gina (se n√£o tiver, assume p√°gina 2)
                const nextPage = userStatus.page ? userStatus.page + 1 : 2;
            
                await processSearch(userStatus.last_query, sender, conn, nextPage);
                return;
            }            
            if (/^2$|nova.*pesquisa/i.test(normalizedText)) {
                console.log("üìå [BOT] Usu√°rio quer fazer uma nova pesquisa.");
                await saveUserState(sender, { status: "waiting_law" });
                await conn.sendMessage(sender, { text: "‚úçÔ∏è *Digite o texto sobre a lei que deseja pesquisar:*\nüí° *Dica:* Sempre inicie sua pesquisa com a palavra *Lei*" });
                return;
            }
            if (/^3$|sair|encerrar/i.test(normalizedText)) {
                console.log("üîö [BOT] Usu√°rio escolheu sair. Encerrando intera√ß√£o.");
                
                await conn.sendMessage(sender, { text: "‚úÖ *Sess√£o encerrada.* Se precisar novamente, basta enviar 'Oi'." });
                
                await deleteUserState(sender); // üîπ Agora, reseta o estado corretamente
                return;
            }
        }

        if (/^(oi|ol√°|bom dia|boa tarde|boa noite)$/i.test(normalizedText)) {
            console.log("üîπ [BOT] Cumprimento detectado, enviando mensagem inicial.");
            await sendInitialMessage(sender, conn);
            return;
        }

        if (userStatus.status === "menu_inicial") {
            if (/^1$|enviar.*pdf/i.test(normalizedText)) {
                console.log("üìå [BOT] Usu√°rio quer enviar um PDF.");
                await saveUserState(sender, { status: "waiting_pdf" });
                await conn.sendMessage(sender, { text: "üìÑ *Aguardando o envio do PDF...*\nCaso queira cancelar, digite *3 - ‚ùå Sair*." });
                return;
            }
            if (/^2$|pesquisar.*lei/i.test(normalizedText)) {
                console.log("üìå [BOT] Usu√°rio quer pesquisar uma lei.");
                await saveUserState(sender, { status: "waiting_law" });
                await conn.sendMessage(sender, { text: "‚úçÔ∏è *Digite o texto sobre a lei que deseja pesquisar:*\nüí° *Dica:* Sempre inicie sua pesquisa com a palavra *Lei*" });
                return;
            }
        }
    });
}

/**
 * ‚è∞ Retorna uma sauda√ß√£o personalizada baseada no hor√°rio do dia
 */
function getGreeting() {
    const hora = new Date().getHours();
    if (hora >= 5 && hora < 12) return "üåÖ Bom dia!";
    if (hora >= 12 && hora < 18) return "üåû Boa tarde!";
    return "üåô Boa noite!";
}

/**
 * üìÑ Processa um PDF enviado, realiza a busca na API e retorna leis similares com % de similaridade.
 */
async function processPDF(sender, conn, fileBuffer, fileName) {
    try {
        console.log("üìÑ [BOT] PDF recebido. Processando...");
        await conn.sendMessage(sender, { text: "üìÑ *Documento recebido!* Analisando leis similares, aguarde..." });

        const formData = new FormData();
        formData.append("file", fileBuffer, { filename: fileName });

        console.log("üöÄ [API] Enviando PDF para an√°lise...");
        const response = await axios.post(`${API_URL}/analisar-pdf`, formData, {
            headers: { ...formData.getHeaders() }
        });

        console.log("‚úÖ [API] Resposta recebida com sucesso!");
        const data = response.data;

        if (!data.results || data.results.length === 0) {
            console.log("‚ö†Ô∏è [BOT] Nenhuma lei similar encontrada.");
            await conn.sendMessage(sender, { text: "‚ö†Ô∏è Nenhuma lei similar encontrada para este documento." });
            return;
        }

        /**
         * üîπ Formata a resposta para pesquisa via PDF (incluindo similaridade %).
         */
        let message = "üìú *Leis similares encontradas:* \n\n";
        data.results.forEach((law, index) => {
            message += `üìå *${law.title}*\n`; // üîπ Exibe o t√≠tulo da lei similar encontrada
            message += `üîç *Similaridade:* ${law.similarity ? `${law.similarity}%` : "N/A"}\n`; // üîπ Exibe a % de similaridade
            message += `üìÑ *Resumo:* ${law.summary || law.snippet || "Sem resumo dispon√≠vel."}\n`; // üîπ Mostra um resumo da lei
            message += `üîó [Acesse Aqui](${law.link})\n\n`; // üîπ Adiciona o link para acessar a lei completa
        });

        console.log("üì§ [BOT] Enviando resultado para o usu√°rio...");
        await conn.sendMessage(sender, { text: message });

        // üîπ Ap√≥s enviar a resposta, apaga o estado do usu√°rio
        await deleteUserState(sender);
    } catch (error) {
        console.error("‚ùå [API] Erro ao processar PDF:", error.message);
        await conn.sendMessage(sender, { text: "‚ùå Erro ao processar o PDF. Tente novamente mais tarde." });
    }
}

// üöÄ Inicia o bot
startBot();
module.exports = { startBot };










API:
require('dotenv').config();
const express = require('express');
const axios = require('axios');
const redis = require('redis');
const morgan = require('morgan');
const sanitize = require('sanitize-html');
const rateLimit = require('express-rate-limit');
const multer = require('multer');
const pdfParse = require('pdf-parse');
const Tesseract = require('tesseract.js');

const app = express();
const PORT = 4000;
const RESULTS_PER_PAGE = 5;
const upload = multer();

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// üîπ Configura√ß√£o do Redis
const client = redis.createClient();
client.connect().catch((err) => console.error("‚ùå [API] Erro ao conectar ao Redis:", err));

// üîπ Middleware para logs organizados
app.use(morgan('tiny'));

// üîπ Middleware de seguran√ßa para limitar requisi√ß√µes
const limiter = rateLimit({
    windowMs: 60 * 1000,
    max: 30,
    message: "‚ö†Ô∏è [API] Limite de requisi√ß√µes excedido. Tente novamente mais tarde."
});
app.use(limiter);

// üîπ Configura√ß√£o de APIs externas
const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY;
const GOOGLE_CX = process.env.GOOGLE_CX;
const MISTRAL_API_KEY = process.env.MISTRAL_API_KEY;

if (!GOOGLE_API_KEY || !GOOGLE_CX || !MISTRAL_API_KEY) {
    console.error("‚ùå [API] ERRO: Faltando vari√°veis de ambiente (GOOGLE_API_KEY, GOOGLE_CX ou MISTRAL_API_KEY). ");
    process.exit(1);
}

const CUSTOM_SEARCH_URL = `https://www.googleapis.com/customsearch/v1?key=${GOOGLE_API_KEY}&cx=${GOOGLE_CX}`;
const MISTRAL_API_URL = "https://api.mistral.ai/v1/chat/completions";

// üìå **Fun√ß√£o de Log**
function logAction(type, message) {
    console.log(`üìå [${type.toUpperCase()}] ${message}`);
}

// üìå **Lista de palavras-chave jur√≠dicas**
const legalKeywords = [
    "lei", "c√≥digo", "regulamento", "norma", "direito", "portaria",
    "decreto", "constitui√ß√£o", "jur√≠dico", "justi√ßa", "processo", "legisla√ß√£o",
    "estatuto", "resolu√ß√£o", "tribunal", "decis√£o", "juiz", "promulga√ß√£o", "sancionada"
];

// üìå **Sanitiza√ß√£o e Valida√ß√£o de Input**
function sanitizeQuery(query) {
    return sanitize(query.replace(/[^a-zA-Z0-9√Ä-√ø\s]/g, '').trim());
}

// üìå **Garante que "Lei" est√° no in√≠cio da pesquisa**
function ensureLawPrefix(query) {
    query = sanitizeQuery(query);
    const words = query.toLowerCase().split(" ");
    if (!legalKeywords.includes(words[0])) {
        return `Lei ${query}`;
    }
    return query;
}

// üìå **Busca no Google Custom Search com pagina√ß√£o**
async function searchGoogle(query, page = 1) {
    const startIndex = (page - 1) * RESULTS_PER_PAGE + 1;
    const googleApiUrl = `${CUSTOM_SEARCH_URL}&q=${encodeURIComponent(query)}&num=${RESULTS_PER_PAGE}&gl=br&start=${startIndex}`;

    try {
        logAction("API", `üîç Buscando no Google: ${query} (P√°gina ${page})`);
        const response = await axios.get(googleApiUrl);

        if (!response.data.items) return [];

        // üîπ Filtra poss√≠veis duplica√ß√µes nos resultados
        const uniqueResults = response.data.items.filter((item, index, self) =>
            index === self.findIndex((t) => t.link === item.link)
        );

        return uniqueResults;
    } catch (error) {
        logAction("ERRO", "Erro ao buscar no Google: " + error.message);
        return [];
    }
}

// üìú **Endpoint para buscar leis com suporte √† pagina√ß√£o**
app.get(['/search', '/buscar'], async (req, res) => {
    let query = req.query.q;
    let page = parseInt(req.query.page) || 1;

    if (!query) {
        return res.status(400).json({ error: 'O par√¢metro "q" √© obrigat√≥rio' });
    }

    query = ensureLawPrefix(query);
    logAction("API", `Pesquisa recebida: ${query} - P√°gina ${page}`);

    const cacheKey = `search-law:${query}:page:${page}`;
    const cachedData = await client.get(cacheKey);

    if (cachedData) {
        logAction("CACHE", `‚ôªÔ∏è Recuperando do cache para "${query}" (P√°gina ${page})`);
        return res.json(JSON.parse(cachedData));
    }

    let results = await searchGoogle(query, page);

    if (!results || results.length === 0) {
        return res.json({
            message: `‚ö†Ô∏è Nenhuma lei encontrada para "${query}".\n\nüí° *Dica:* Tente reformular sua pesquisa come√ßando com "Lei".`
        });
    }

    const responsePayload = {
        message: "üìú Leis encontradas:",
        results: results.slice(0, RESULTS_PER_PAGE),
        nextPage: results.length === RESULTS_PER_PAGE ? `/buscar?q=${encodeURIComponent(query)}&page=${page + 1}` : null
    };

    await client.setEx(cacheKey, 1800, JSON.stringify(responsePayload)); // Cache por 30 minutos

    return res.json(responsePayload);
});

app.post('/buscar', async (req, res) => {
    let query = req.body.q;
    let page = parseInt(req.body.page) || 1;

    if (!query) {
        return res.status(400).json({ error: 'O par√¢metro "q" √© obrigat√≥rio no corpo da requisi√ß√£o' });
    }

    query = ensureLawPrefix(query);
    logAction("API", `Pesquisa recebida via POST: ${query} - P√°gina ${page}`);

    const cacheKey = `search-law:${query}:page:${page}`;
    const cachedData = await client.get(cacheKey);

    if (cachedData) {
        logAction("CACHE", `‚ôªÔ∏è Recuperando do cache para "${query}" (P√°gina ${page})`);
        return res.json(JSON.parse(cachedData));
    }

    let results = await searchGoogle(query, page);

    if (!results || results.length === 0) {
        return res.json({
            message: `‚ö†Ô∏è Nenhuma lei encontrada para "${query}".\n\nüí° *Dica:* Tente reformular sua pesquisa come√ßando com "Lei".`
        });
    }

    const responsePayload = {
        message: "üìú Leis encontradas:",
        results: results.slice(0, RESULTS_PER_PAGE),
        nextPage: results.length === RESULTS_PER_PAGE ? `/buscar?q=${encodeURIComponent(query)}&page=${page + 1}` : null
    };

    await client.setEx(cacheKey, 1800, JSON.stringify(responsePayload)); // Cache por 30 minutos

    return res.json(responsePayload);
});

// üöÄ **Inicia a API**
app.listen(PORT, () => {
    logAction("API", `API de Pesquisa de Leis rodando na porta ${PORT}`);
    logAction("API", `Alias dispon√≠veis: "/search", "/buscar" e "/analisar-pdf"`);
});
